var Emitter   = require('events').EventEmitter;
var nopt      = require('nopt');
var path      = require('path');
var fs        = require('fs');
var _         = require('lodash');
var csv       = require('csv');
var fileExists  = require('../util/file-exists');
var dateFormat  = require('../util/date-format');

var template = require('../util/template');
var help     = require('./help');

var optionTypes = { help: Boolean, 'savelog': Boolean };
var shorthand   = { 'h': ['--help'], 'sl': ['--savelog'] };

/**
 * default log file name
 * @type {String}
 */
var logFileName = 'sample.csv.log';

/**
 * current date to save to log file
 * @type {date}
 */
var dateNow = dateFormat(new Date(), 'dd/mm/yyyy hh:mm:ss');

/**
 * errorData object is used to push all sample errors and then save them to the log file
 * @type {Object}
 */
var errorData = {
    checkSampleHeader: {
        title: 'Sample Header Errors',
        errors: []
    },
    checkSampleData: {
        title: 'Sample Data Errors',
        errors: []
    }
};

/**
 * Implemented toLowerCase function for arrays.
 * @return {array} returns the array converted to lower case.
 */
Array.prototype.toLowerCase = function () {
    var i = this.length;
    while (--i >= 0) {
        if (typeof this[i] === 'string') {
            this[i] = this[i].toLowerCase();
        }
    }
    return this;
};

/**
 * save to a log file the errors found when checking the sample
 * @param  {object} errorData contains the name of the check and the errors found (name, value, location)
 * @return {file} append to log file. It creates the file if it doesn't exist
 */
var saveToLogFile = function (errorData) {
    fs.appendFileSync(logFileName, errorData + '\n');
};

/**
 * check sample header for missing columns, spaces inside column names and bad formating (invalid chars).
 * @param  {object} emitter object used to emit events
 * @param  {boolean} saveLog
 * @param  {array} dataRow array obejct containing data for current parsed row
 * @return {n/a}
 */
var checkSampleHeader = function (emitter, saveLog, dataRow) {
    var errorCount = 0;
    var errTxt = '';

    // mandatory columns in a sample file
    var mandatoryColumns = ['id', 'stype', 'batch', 'email', 'unsubscribe', 'returncode'];

    dataRow = dataRow.toLowerCase();

    // check if mandatory columns are missing
    for (var i = 0; i < mandatoryColumns.length; i++) {
        if (!_.contains(dataRow, mandatoryColumns[i])) {
            errTxt = 'column\t' + mandatoryColumns[i] + '\tis missing';
            errorData.checkSampleHeader.errors.push(errTxt);
            errorCount++;

            emitter.emit('data', template('error-check-sample', {where: 'header', what: 'column', value: mandatoryColumns[i], message: 'is missing'}, true));
        }
    }

    // check header for spaces and invalid chars
    for (i = 0; i < dataRow.length; i++) {
        if (/(\s)/.test(dataRow[i])) {
            errTxt = 'column\t' + dataRow[i] + '\tcontains spaces';
            errorData.checkSampleHeader.errors.push(errTxt);
            errorCount++;

            emitter.emit('data', template('error-check-sample', {where: 'header', what: 'column', value: dataRow[i], message: 'contains spaces'}, true));
        }
        if (!/^[a-zA-Z\d_]+$/.test(dataRow[i].replace(/(\s)/gm, ''))) {
            errTxt = 'column\t' + dataRow[i] + '\tcontains invalid chars';
            errorData.checkSampleHeader.errors.push(errTxt);
            errorCount++;

            emitter.emit('data', template('error-check-sample', {where: 'header', what: 'column', value: dataRow[i], message: 'contains invalid chars'}, true));
        }
    }

    // header checking done
    template('action', { name: 'header checked', shizzle: errorCount + ' error(s) found' })
            .on('data', emitter.emit.bind(emitter, 'data'));
};

/**
 * checks the sample data for errors, invalid email name, invalid chars, empty lines, do not contact panelists
 * @param  {object} emitter object used to emit events
 * @param  {booblean} saveLog
 * @param  {array} dataRow array obejct containing data for current parsed row
 * @param  {object} opts options used for sample checking (rowIndex, emailIndex)
 * @return {n/a}
 */
var checkSampleData = function (emitter, saveLog, dataRow, opts) {
    var errorCount = 0;
    var errTxt = '';

    // Validate email and `do not contact` list
    if (opts.emailIndex !== -1) {
        // Validate email name
        var emailExpr = /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/;
        var email     = dataRow[opts.emailIndex];

        if (!emailExpr.test(email.replace(/(\r\n|\n|\r)/gm, ''))) {
            errTxt = 'email\t' + opts.rowIndex + '\t' + email + '\tis not valid';
            errorData.checkSampleData.errors.push(errTxt);
            errorCount++;

            emitter.emit('data', template('error-check-sample', {where: opts.rowIndex, what: 'email', value: email, message: 'is not valid'}, true));
        } else {
            // Check emails against `do not contact` list
            var doNotContactDataFile = path.resolve(path.join(__dirname, '../../data/do_not_contact_list.json'));
            var list = JSON.parse(fs.readFileSync(doNotContactDataFile, {'encoding': 'utf8'}));
            email = dataRow[opts.emailIndex];

            for (var j = 0; j < list.length; j++) {
                if (email === list[j].email) {
                    errTxt = 'email\t' + opts.rowIndex + '\t' + email + '\tis on the `do not contact` list';
                    errorData.checkSampleData.errors.push(errTxt);
                    errorCount++;

                    emitter.emit('data', template('error-check-sample', {where: opts.rowIndex, what: 'email', value: email, message: 'is on the `do not contact` list'}, true));

                    break;
                }
            }
        }
    }

    // Validate row (empty line, invalid chars)
    var lineEmpty = true;
    var lineInvalidChar = false;
    for (var i = 0; i < dataRow.length; i++) {
        if (lineEmpty && dataRow[i].replace(/(\r\n|\n|\r)/gm, '').replace(/\s+/g, '') !== '') {
            lineEmpty = false;
        }

        if (/[^\x00-\x7F]/.test(dataRow[i])) {
            lineInvalidChar = true;
        }
    }

    if (lineEmpty) {
        errTxt = 'line\t' + opts.rowIndex + '\tis empty';
        errorData.checkSampleData.errors.push(errTxt);
        errorCount++;

        emitter.emit('data', template('error-check-sample', {where: opts.rowIndex, what: 'line', value: opts.rowIndex, message: 'is empty'}, true));
    }

    if (lineInvalidChar) {
        errTxt = 'line\t' + opts.rowIndex + '\tcontains invalid chars';
        errorData.checkSampleData.errors.push(errTxt);
        errorCount++;

        emitter.emit('data', template('error-check-sample', {where: opts.rowIndex, what: 'line', value: opts.rowIndex, message: 'contains invalid chars'}, true));
    }
};

module.exports = function (sampleFile, options) {
    options = options || {};

    var emitter = new Emitter;

    var workingFolder  = process.cwd();

    // check if sample file exists first
    fileExists(path.resolve(path.join(workingFolder, sampleFile)), function (exists) {
        if (!exists) {
            return emitter.emit('error', new Error('the sample file ' + sampleFile + ' doesn`t exist'));
        } else {
            var saveLog = options.savelog;

            var opts = {
                rowIndex: 0,
                emailIndex: 0
            };

            emitter.emit('data', template('action', { name: 'checking ', shizzle: sampleFile}, true));

            // parse sample file
            var csvParser = csv().from.path(path.resolve(path.join(workingFolder, sampleFile))).on('record', function (row, index) {
                if (index === 0) {
                    opts.emailIndex = _.indexOf(row.toLowerCase(), 'email');

                    if (opts.emailIndex === -1) {
                        emitter.emit('warn', 'email column not found');
                    }

                    checkSampleHeader(emitter, saveLog, row);
                } else {
                    opts.rowIndex = index;

                    checkSampleData(emitter, saveLog, row, opts);
                }
            });

            // parsing finished, save errors to log file
            csvParser.on('end', function (count) {
                emitter.emit('data', template('action', { name: 'finished parsing sample file', shizzle: count + ' rows'}, true));

                if (saveLog) {
                    saveToLogFile(dateNow + '\n');
                    saveToLogFile(_(errorData.checkSampleHeader.errors).forEach().join('\n'));
                    saveToLogFile(_(errorData.checkSampleData.errors).forEach().join('\n'));

                    emitter.emit('data', template('action', { name: 'finished saving log file', shizzle: (errorData.checkSampleHeader.errors.length + errorData.checkSampleData.errors.length) + ' errors'}, true));
                }

            });

            emitter.emit('end');
        }
    });

    return emitter;
};

module.exports.line = function (argv) {
    var options  = nopt(optionTypes, shorthand, argv);
    var sampleFile = options.argv.remain.slice(1);

    if (options.help || sampleFile.length !== 1) return help('check-sample');

    if (options.help) return help('check-sample');

    logFileName = sampleFile[0] + '.log';

    return module.exports(sampleFile[0], options);
};

module.exports.completion = function (opts, cb) {
    fs.readdir(process.cwd(), function (err, files) {
        // ignore ENOENT, no files
        if (err && err.code === 'ENOENT') return cb(null, []);
        cb(err, files);
    });
};

module.exports.completion.options = shorthand;
